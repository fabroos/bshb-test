// This file was generated by basehub. Do not edit directly. Read more: https://basehub.com/docs/api-reference/basehub-sdk

/* eslint-disable */
/* eslint-disable eslint-comments/no-restricted-disable */
/* tslint:disable */

// @ts-nocheck
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

export type Scalars = {
    Boolean: boolean,
    DateTime: any,
    Float: number,
    ID: string,
    Int: number,
    JSON: any,
    String: string,
}

export type AnalyticsKeyScope = 'query' | 'send'

export interface BaseRichTextJson {
    blocks: Scalars['String']
    content: Scalars['JSON']
    toc: Scalars['JSON']
    __typename: 'BaseRichTextJson'
}

export interface BlockAudio {
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    __typename: 'BlockAudio'
}

export interface BlockCodeSnippet {
    allowedLanguages: Scalars['String'][]
    code: Scalars['String']
    /** @deprecated Figuring out the correct api. */
    html: Scalars['String']
    language: Scalars['String']
    __typename: 'BlockCodeSnippet'
}

export interface BlockColor {
    b: Scalars['Int']
    g: Scalars['Int']
    hex: Scalars['String']
    hsl: Scalars['String']
    r: Scalars['Int']
    rgb: Scalars['String']
    __typename: 'BlockColor'
}

export type BlockDocument = (Sarasa) & { __isUnion?: true }

export interface BlockDocumentSys {
    apiNamePath: Scalars['String']
    createdAt: Scalars['String']
    hash: Scalars['String']
    id: Scalars['ID']
    idPath: Scalars['String']
    lastModifiedAt: Scalars['String']
    slug: Scalars['String']
    slugPath: Scalars['String']
    title: Scalars['String']
    __typename: 'BlockDocumentSys'
}

export interface BlockFile {
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    __typename: 'BlockFile'
}

export interface BlockImage {
    alt: (Scalars['String'] | null)
    aspectRatio: Scalars['String']
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    height: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    placeholderURL: Scalars['String']
    /** @deprecated Use `url` instead. */
    rawUrl: Scalars['String']
    thumbhash: Scalars['String']
    /**
     * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
     * 
     * ```graphql
     * {
     *   blockImage {
     *     url(width: 200, height: 200)
     *   }
     * }
     * ```
     * 
     * This will return the URL with the width and height set to 200 pixels.
     * 
     * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
     * 
     */
    url: Scalars['String']
    width: Scalars['Int']
    __typename: 'BlockImage'
}

export interface BlockList {
    _analyticsKey: Scalars['String']
    _id: Scalars['String']
    _idPath: Scalars['String']
    _meta: ListMeta
    /** The key used to search from the frontend. */
    _searchKey: Scalars['String']
    _slug: Scalars['String']
    _slugPath: Scalars['String']
    _sys: BlockDocumentSys
    _title: Scalars['String']
    __typename: string
}

export interface BlockOgImage {
    url: Scalars['String']
    __typename: 'BlockOgImage'
}


/** Rich text block */
export interface BlockRichText {
    html: Scalars['String']
    json: RichTextJson
    markdown: Scalars['String']
    plainText: Scalars['String']
    readingTime: Scalars['Int']
    __typename: string
}

export interface BlockVideo {
    aspectRatio: Scalars['String']
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    height: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    width: Scalars['Int']
    __typename: 'BlockVideo'
}

export interface ListMeta {
    totalCount: Scalars['Int']
    __typename: 'ListMeta'
}

export interface Query {
    _sys: RepoSys
    sarasa: Sarasa
    __typename: 'Query'
}

export interface RepoSys {
    hash: Scalars['String']
    id: Scalars['ID']
    slug: Scalars['String']
    title: Scalars['String']
    __typename: 'RepoSys'
}

export type RichTextJson = (BaseRichTextJson) & { __isUnion?: true }

export interface Sarasa {
    _analyticsKey: Scalars['String']
    _id: Scalars['String']
    _idPath: Scalars['String']
    _slug: Scalars['String']
    _slugPath: Scalars['String']
    _sys: BlockDocumentSys
    _title: Scalars['String']
    title: Scalars['String']
    __typename: 'Sarasa'
}

export interface BaseRichTextJsonGenqlSelection{
    blocks?: boolean | number
    content?: boolean | number
    toc?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockAudioGenqlSelection{
    fileName?: boolean | number
    fileSize?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockCodeSnippetGenqlSelection{
    allowedLanguages?: boolean | number
    code?: boolean | number
    /** @deprecated Figuring out the correct api. */
    html?: { __args: {
    /** Theme for the code snippet */
    theme?: (Scalars['String'] | null)} } | boolean | number
    language?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockColorGenqlSelection{
    b?: boolean | number
    g?: boolean | number
    hex?: boolean | number
    hsl?: boolean | number
    r?: boolean | number
    rgb?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockDocumentGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    on_Sarasa?: SarasaGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockDocumentSysGenqlSelection{
    apiNamePath?: boolean | number
    createdAt?: boolean | number
    hash?: boolean | number
    id?: boolean | number
    idPath?: boolean | number
    lastModifiedAt?: boolean | number
    slug?: boolean | number
    slugPath?: boolean | number
    title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockFileGenqlSelection{
    fileName?: boolean | number
    fileSize?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockImageGenqlSelection{
    alt?: boolean | number
    aspectRatio?: boolean | number
    fileName?: boolean | number
    fileSize?: boolean | number
    height?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    placeholderURL?: boolean | number
    /** @deprecated Use `url` instead. */
    rawUrl?: boolean | number
    thumbhash?: boolean | number
    /**
     * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
     * 
     * ```graphql
     * {
     *   blockImage {
     *     url(width: 200, height: 200)
     *   }
     * }
     * ```
     * 
     * This will return the URL with the width and height set to 200 pixels.
     * 
     * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
     * 
     */
    url?: { __args: {anim?: (Scalars['String'] | null), background?: (Scalars['String'] | null), blur?: (Scalars['Int'] | null), border?: (Scalars['String'] | null), brightness?: (Scalars['Int'] | null), compression?: (Scalars['String'] | null), contrast?: (Scalars['Int'] | null), dpr?: (Scalars['Int'] | null), fit?: (Scalars['String'] | null), format?: (Scalars['String'] | null), gamma?: (Scalars['String'] | null), gravity?: (Scalars['String'] | null), height?: (Scalars['Int'] | null), metadata?: (Scalars['String'] | null), quality?: (Scalars['Int'] | null), rotate?: (Scalars['String'] | null), sharpen?: (Scalars['String'] | null), trim?: (Scalars['String'] | null), width?: (Scalars['Int'] | null)} } | boolean | number
    width?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockListGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _meta?: ListMetaGenqlSelection
    /** The key used to search from the frontend. */
    _searchKey?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockOgImageGenqlSelection{
    url?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}


/** Rich text block */
export interface BlockRichTextGenqlSelection{
    html?: { __args: {
    /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
    slugs?: (Scalars['Boolean'] | null), 
    /** Inserts a table of contents at the beginning of the HTML. */
    toc?: (Scalars['Boolean'] | null)} } | boolean | number
    json?: RichTextJsonGenqlSelection
    markdown?: boolean | number
    plainText?: boolean | number
    readingTime?: { __args: {
    /** Words per minute, defaults to average 183wpm */
    wpm?: (Scalars['Int'] | null)} } | boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockVideoGenqlSelection{
    aspectRatio?: boolean | number
    fileName?: boolean | number
    fileSize?: boolean | number
    height?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    width?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface DateFilter {eq?: (Scalars['DateTime'] | null),isAfter?: (Scalars['DateTime'] | null),isBefore?: (Scalars['DateTime'] | null),neq?: (Scalars['DateTime'] | null),onOrAfter?: (Scalars['DateTime'] | null),onOrBefore?: (Scalars['DateTime'] | null)}

export interface ListFilter {isEmpty?: (Scalars['Boolean'] | null),length?: (Scalars['Int'] | null)}

export interface ListMetaGenqlSelection{
    totalCount?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface NumberFilter {eq?: (Scalars['Float'] | null),gt?: (Scalars['Float'] | null),gte?: (Scalars['Float'] | null),lt?: (Scalars['Float'] | null),lte?: (Scalars['Float'] | null),neq?: (Scalars['Float'] | null)}

export interface QueryGenqlSelection{
    _sys?: RepoSysGenqlSelection
    sarasa?: SarasaGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface RepoSysGenqlSelection{
    hash?: boolean | number
    id?: boolean | number
    slug?: boolean | number
    title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface RichTextJsonGenqlSelection{
    content?: boolean | number
    toc?: boolean | number
    on_BaseRichTextJson?: BaseRichTextJsonGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface SarasaGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface StringFilter {contains?: (Scalars['String'] | null),endsWith?: (Scalars['String'] | null),eq?: (Scalars['String'] | null),matches?: (StringMatchesFilter | null),notEq?: (Scalars['String'] | null),startsWith?: (Scalars['String'] | null)}

export interface StringMatchesFilter {caseSensitive?: (Scalars['Boolean'] | null),pattern: Scalars['String']}

type FragmentsMap = {
  BaseRichTextJson: {
    root: BaseRichTextJson,
    selection: BaseRichTextJsonGenqlSelection,
}
  BlockAudio: {
    root: BlockAudio,
    selection: BlockAudioGenqlSelection,
}
  BlockCodeSnippet: {
    root: BlockCodeSnippet,
    selection: BlockCodeSnippetGenqlSelection,
}
  BlockColor: {
    root: BlockColor,
    selection: BlockColorGenqlSelection,
}
  BlockDocument: {
    root: BlockDocument,
    selection: BlockDocumentGenqlSelection,
}
  BlockDocumentSys: {
    root: BlockDocumentSys,
    selection: BlockDocumentSysGenqlSelection,
}
  BlockFile: {
    root: BlockFile,
    selection: BlockFileGenqlSelection,
}
  BlockImage: {
    root: BlockImage,
    selection: BlockImageGenqlSelection,
}
  BlockList: {
    root: BlockList,
    selection: BlockListGenqlSelection,
}
  BlockOgImage: {
    root: BlockOgImage,
    selection: BlockOgImageGenqlSelection,
}
  BlockRichText: {
    root: BlockRichText,
    selection: BlockRichTextGenqlSelection,
}
  BlockVideo: {
    root: BlockVideo,
    selection: BlockVideoGenqlSelection,
}
  ListMeta: {
    root: ListMeta,
    selection: ListMetaGenqlSelection,
}
  Query: {
    root: Query,
    selection: QueryGenqlSelection,
}
  RepoSys: {
    root: RepoSys,
    selection: RepoSysGenqlSelection,
}
  RichTextJson: {
    root: RichTextJson,
    selection: RichTextJsonGenqlSelection,
}
  Sarasa: {
    root: Sarasa,
    selection: SarasaGenqlSelection,
}
}

import { FieldsSelection } from "./runtime";

export function fragmentOn<
    TypeName extends keyof FragmentsMap,
    Selection extends FragmentsMap[TypeName]["selection"],
>(name: TypeName, fields: Selection) {
  return { __fragmentOn: name, ...fields } as const;
}

// credits: https://stackoverflow.com/a/54487392
type OmitDistributive<T, K extends PropertyKey> = T extends any
    ? T extends object
        ? Id<OmitRecursively<T, K>>
        : T
    : never
type Id<T> = {} & { [P in keyof T]: T[P] } // Cosmetic use only makes the tooltips expad the type can be removed
type OmitRecursively<T, K extends PropertyKey> = Omit<
    { [P in keyof T]: OmitDistributive<T[P], K> },
    K
>

export namespace fragmentOn {
    export type infer<T> = T extends {
      __fragmentOn: infer U extends keyof FragmentsMap;
    }
      ? OmitRecursively<FieldsSelection<FragmentsMap[U]["root"], Omit<T, "__fragmentOn">>, "__fragmentOn">
      : never;
  }


// This is a BaseHub-specific thing:

type RecursiveCollection<T, Key extends keyof T> = T & {
[key in Key]: { items: RecursiveCollection<T, Key> };
};

export function fragmentOnRecursiveCollection<
  TypeName extends keyof FragmentsMap,
  Selection extends FragmentsMap[TypeName]["selection"],
  RecursiveKey extends keyof FragmentsMap[TypeName]["selection"]
>(
  name: TypeName,
  fields: Selection,
  options: {
    recursiveKey: RecursiveKey;
    levels: number;
    getLevelArgs?: (level: number) => unknown;
  }
) {
  let current = {
    ...fields,
  } as RecursiveCollection<
    { readonly __fragmentOn: TypeName } & Selection,
    RecursiveKey
  >;
  if (options.levels > 0) {
    current[options.recursiveKey] = {
      ...(options.getLevelArgs
        ? { __args: options.getLevelArgs(options.levels) }
        : {}),
      items: fragmentOnRecursiveCollection(name, fields, {
        ...options,
        levels: options.levels - 1,
      }),
    } as any;
  }
  return current;
}




    const BaseRichTextJson_possibleTypes: string[] = ['BaseRichTextJson']
    export const isBaseRichTextJson = (obj?: { __typename?: any } | null): obj is BaseRichTextJson => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBaseRichTextJson"')
      return BaseRichTextJson_possibleTypes.includes(obj.__typename)
    }
    


    const BlockAudio_possibleTypes: string[] = ['BlockAudio']
    export const isBlockAudio = (obj?: { __typename?: any } | null): obj is BlockAudio => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockAudio"')
      return BlockAudio_possibleTypes.includes(obj.__typename)
    }
    


    const BlockCodeSnippet_possibleTypes: string[] = ['BlockCodeSnippet']
    export const isBlockCodeSnippet = (obj?: { __typename?: any } | null): obj is BlockCodeSnippet => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockCodeSnippet"')
      return BlockCodeSnippet_possibleTypes.includes(obj.__typename)
    }
    


    const BlockColor_possibleTypes: string[] = ['BlockColor']
    export const isBlockColor = (obj?: { __typename?: any } | null): obj is BlockColor => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockColor"')
      return BlockColor_possibleTypes.includes(obj.__typename)
    }
    


    const BlockDocument_possibleTypes: string[] = ['Sarasa']
    export const isBlockDocument = (obj?: { __typename?: any } | null): obj is BlockDocument => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockDocument"')
      return BlockDocument_possibleTypes.includes(obj.__typename)
    }
    


    const BlockDocumentSys_possibleTypes: string[] = ['BlockDocumentSys']
    export const isBlockDocumentSys = (obj?: { __typename?: any } | null): obj is BlockDocumentSys => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockDocumentSys"')
      return BlockDocumentSys_possibleTypes.includes(obj.__typename)
    }
    


    const BlockFile_possibleTypes: string[] = ['BlockFile']
    export const isBlockFile = (obj?: { __typename?: any } | null): obj is BlockFile => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockFile"')
      return BlockFile_possibleTypes.includes(obj.__typename)
    }
    


    const BlockImage_possibleTypes: string[] = ['BlockImage']
    export const isBlockImage = (obj?: { __typename?: any } | null): obj is BlockImage => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockImage"')
      return BlockImage_possibleTypes.includes(obj.__typename)
    }
    


    const BlockList_possibleTypes: string[] = []
    export const isBlockList = (obj?: { __typename?: any } | null): obj is BlockList => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockList"')
      return BlockList_possibleTypes.includes(obj.__typename)
    }
    


    const BlockOgImage_possibleTypes: string[] = ['BlockOgImage']
    export const isBlockOgImage = (obj?: { __typename?: any } | null): obj is BlockOgImage => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockOgImage"')
      return BlockOgImage_possibleTypes.includes(obj.__typename)
    }
    


    const BlockRichText_possibleTypes: string[] = []
    export const isBlockRichText = (obj?: { __typename?: any } | null): obj is BlockRichText => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockRichText"')
      return BlockRichText_possibleTypes.includes(obj.__typename)
    }
    


    const BlockVideo_possibleTypes: string[] = ['BlockVideo']
    export const isBlockVideo = (obj?: { __typename?: any } | null): obj is BlockVideo => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockVideo"')
      return BlockVideo_possibleTypes.includes(obj.__typename)
    }
    


    const ListMeta_possibleTypes: string[] = ['ListMeta']
    export const isListMeta = (obj?: { __typename?: any } | null): obj is ListMeta => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isListMeta"')
      return ListMeta_possibleTypes.includes(obj.__typename)
    }
    


    const Query_possibleTypes: string[] = ['Query']
    export const isQuery = (obj?: { __typename?: any } | null): obj is Query => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isQuery"')
      return Query_possibleTypes.includes(obj.__typename)
    }
    


    const RepoSys_possibleTypes: string[] = ['RepoSys']
    export const isRepoSys = (obj?: { __typename?: any } | null): obj is RepoSys => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isRepoSys"')
      return RepoSys_possibleTypes.includes(obj.__typename)
    }
    


    const RichTextJson_possibleTypes: string[] = ['BaseRichTextJson']
    export const isRichTextJson = (obj?: { __typename?: any } | null): obj is RichTextJson => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isRichTextJson"')
      return RichTextJson_possibleTypes.includes(obj.__typename)
    }
    


    const Sarasa_possibleTypes: string[] = ['Sarasa']
    export const isSarasa = (obj?: { __typename?: any } | null): obj is Sarasa => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isSarasa"')
      return Sarasa_possibleTypes.includes(obj.__typename)
    }
    

export const enumAnalyticsKeyScope = {
   query: 'query' as const,
   send: 'send' as const
}
