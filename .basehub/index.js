// This file was generated by basehub. Do not edit directly. Read more: https://basehub.com/docs/api-reference/basehub-sdk

/* eslint-disable */
/* eslint-disable eslint-comments/no-restricted-disable */
/* tslint:disable */

// .basehub/runtime/_error.ts
var GenqlError = class extends Error {
  constructor(errors, data) {
    let message = Array.isArray(errors) ? errors.map((x) => x?.message || "").join("\n") : "";
    if (!message) {
      message = "GraphQL error";
    }
    super(message);
    this.errors = [];
    this.errors = errors;
    this.data = data;
  }
};

// .basehub/runtime/_batcher.ts
function dispatchQueueBatch(client, queue) {
  let batchedQuery = queue.map((item) => item.request);
  if (batchedQuery.length === 1) {
    batchedQuery = batchedQuery[0];
  }
  ;
  (() => {
    try {
      return client.fetcher(batchedQuery);
    } catch (e) {
      return Promise.reject(e);
    }
  })().then((responses) => {
    if (queue.length === 1 && !Array.isArray(responses)) {
      if (responses.errors && responses.errors.length) {
        queue[0].reject(
          new GenqlError(responses.errors, responses.data)
        );
        return;
      }
      queue[0].resolve(responses);
      return;
    } else if (responses.length !== queue.length) {
      throw new Error("response length did not match query length");
    }
    for (let i = 0; i < queue.length; i++) {
      if (responses[i].errors && responses[i].errors.length) {
        queue[i].reject(
          new GenqlError(responses[i].errors, responses[i].data)
        );
      } else {
        queue[i].resolve(responses[i]);
      }
    }
  }).catch((e) => {
    for (let i = 0; i < queue.length; i++) {
      queue[i].reject(e);
    }
  });
}
function dispatchQueue(client, options) {
  const queue = client._queue;
  const maxBatchSize = options.maxBatchSize || 0;
  client._queue = [];
  if (maxBatchSize > 0 && maxBatchSize < queue.length) {
    for (let i = 0; i < queue.length / maxBatchSize; i++) {
      dispatchQueueBatch(
        client,
        queue.slice(i * maxBatchSize, (i + 1) * maxBatchSize)
      );
    }
  } else {
    dispatchQueueBatch(client, queue);
  }
}
var QueryBatcher = class _QueryBatcher {
  constructor(fetcher, {
    batchInterval = 6,
    shouldBatch = true,
    maxBatchSize = 0
  } = {}) {
    this.fetcher = fetcher;
    this._options = {
      batchInterval,
      shouldBatch,
      maxBatchSize
    };
    this._queue = [];
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {promise} resolves to parsed json of server response
   *
   * @example
   * client.fetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  fetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides);
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve, reject) => {
      this._queue.push({
        request,
        resolve,
        reject
      });
      if (this._queue.length === 1) {
        if (options.shouldBatch) {
          setTimeout(
            () => dispatchQueue(this, options),
            options.batchInterval
          );
        } else {
          dispatchQueue(this, options);
        }
      }
    });
    return promise;
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {Promise<Array<Result>>} resolves to parsed json of server response
   *
   * @example
   * client.forceFetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  forceFetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides, {
      shouldBatch: false
    });
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve, reject) => {
      const client = new _QueryBatcher(this.fetcher, this._options);
      client._queue = [
        {
          request,
          resolve,
          reject
        }
      ];
      dispatchQueue(client, options);
    });
    return promise;
  }
};

// .basehub/runtime/_fetcher.ts
var DEFAULT_BATCH_OPTIONS = {
  maxBatchSize: 10,
  batchInterval: 40
};
var createFetcher = ({
  url,
  headers = {},
  fetcher,
  fetch: _fetch,
  batch = false,
  ...rest
}) => {
  if (!url && !fetcher) {
    throw new Error("url or fetcher is required");
  }
  fetcher = fetcher || (async (body) => {
    let headersObject = typeof headers == "function" ? await headers() : headers;
    headersObject = headersObject || {};
    if (typeof fetch === "undefined" && !_fetch) {
      throw new Error(
        "Global `fetch` function is not available, pass a fetch polyfill to Genql `createClient`"
      );
    }
    let fetchImpl = _fetch || fetch;
    const res = await fetchImpl(url, {
      headers: {
        "Content-Type": "application/json",
        ...headersObject
      },
      method: "POST",
      body: JSON.stringify(body),
      ...rest
    });
    if (!res.ok) {
      throw new Error(`${res.statusText}: ${await res.text()}`);
    }
    const json = await res.json();
    return json;
  });
  if (!batch) {
    return async (body) => {
      const json = await fetcher(body);
      if (Array.isArray(json)) {
        return json.map((json2) => {
          if (json2?.errors?.length) {
            throw new GenqlError(json2.errors || [], json2.data);
          }
          return json2.data;
        });
      } else {
        if (json?.errors?.length) {
          throw new GenqlError(json.errors || [], json.data);
        }
        return json.data;
      }
    };
  }
  const batcher = new QueryBatcher(
    async (batchedQuery) => {
      const json = await fetcher(batchedQuery);
      return json;
    },
    batch === true ? DEFAULT_BATCH_OPTIONS : batch
  );
  return async ({ query, variables }) => {
    const json = await batcher.fetch(query, variables);
    if (json?.data) {
      return json.data;
    }
    throw new Error(
      "Genql batch fetcher returned unexpected result " + JSON.stringify(json)
    );
  };
};

// .basehub/runtime/_generate-graphql-operation.ts
var parseRequest = (request, ctx, path) => {
  if (typeof request === "object" && "__args" in request) {
    const args = request.__args;
    let fields = { ...request };
    delete fields.__args;
    const argNames = Object.keys(args);
    if (argNames.length === 0) {
      return parseRequest(fields, ctx, path);
    }
    const field = getFieldFromPath(ctx.root, path);
    const argStrings = argNames.map((argName) => {
      ctx.varCounter++;
      const varName = `v${ctx.varCounter}`;
      const typing = field.args && field.args[argName];
      if (!typing) {
        throw new Error(
          `no typing defined for argument \`${argName}\` in path \`${path.join(
            "."
          )}\``
        );
      }
      const shouldStringifyValue = ["String", "String!"].includes(
        typing[1]
      );
      let value = args[argName];
      if (shouldStringifyValue) {
        if (typeof value === "object") {
          value = JSON.stringify(value);
        }
      }
      ctx.variables[varName] = {
        value,
        typing
      };
      return `${argName}:$${varName}`;
    });
    return `(${argStrings})${parseRequest(fields, ctx, path)}`;
  } else if (typeof request === "object" && Object.keys(request).length > 0) {
    const fields = request;
    const fieldNames = Object.keys(fields).filter((k) => Boolean(fields[k]));
    if (fieldNames.length === 0) {
      throw new Error(
        `field selection should not be empty: ${path.join(".")}`
      );
    }
    const type = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;
    const scalarFields = type.scalar;
    let scalarFieldsFragment;
    if (fieldNames.includes("__scalar")) {
      const falsyFieldNames = new Set(
        Object.keys(fields).filter((k) => !Boolean(fields[k]))
      );
      if (scalarFields?.length) {
        ctx.fragmentCounter++;
        scalarFieldsFragment = `f${ctx.fragmentCounter}`;
        ctx.fragments.push(
          `fragment ${scalarFieldsFragment} on ${type.name}{${scalarFields.filter((f) => !falsyFieldNames.has(f)).join(",")}}`
        );
      }
    }
    const fieldsSelection = fieldNames.filter((f) => !["__scalar", "__name", "__fragmentOn"].includes(f)).map((f) => {
      const parsed = parseRequest(fields[f], ctx, [...path, f]);
      if (f.startsWith("on_")) {
        ctx.fragmentCounter++;
        const implementationFragment = `f${ctx.fragmentCounter}`;
        const typeMatch = f.match(/^on_(.+)/);
        if (!typeMatch || !typeMatch[1])
          throw new Error("match failed");
        ctx.fragments.push(
          `fragment ${implementationFragment} on ${typeMatch[1]}${parsed}`
        );
        return `...${implementationFragment}`;
      } else {
        return `${f}${parsed}`;
      }
    }).concat(scalarFieldsFragment ? [`...${scalarFieldsFragment}`] : []).join(",");
    return `{${fieldsSelection}}`;
  } else {
    return "";
  }
};
var generateGraphqlOperation = (operation, root, fields) => {
  const ctx = {
    root,
    varCounter: 0,
    variables: {},
    fragmentCounter: 0,
    fragments: []
  };
  const result = parseRequest(fields, ctx, []);
  const varNames = Object.keys(ctx.variables);
  const varsString = varNames.length > 0 ? `(${varNames.map((v) => {
    const variableType = ctx.variables[v].typing[1];
    return `$${v}:${variableType}`;
  })})` : "";
  const operationName = fields?.__name || "";
  return {
    query: [
      `${operation} ${operationName}${varsString}${result}`,
      ...ctx.fragments
    ].join(","),
    variables: Object.keys(ctx.variables).reduce(
      (r, v) => {
        r[v] = ctx.variables[v].value;
        return r;
      },
      {}
    ),
    ...operationName ? { operationName: operationName.toString() } : {}
  };
};
var getFieldFromPath = (root, path) => {
  let current;
  if (!root)
    throw new Error("root type is not provided");
  if (path.length === 0)
    throw new Error(`path is empty`);
  path.forEach((f) => {
    const type = current ? current.type : root;
    if (!type.fields)
      throw new Error(`type \`${type.name}\` does not have fields`);
    const possibleTypes = Object.keys(type.fields).filter((i) => i.startsWith("on_")).reduce(
      (types, fieldName) => {
        const field2 = type.fields && type.fields[fieldName];
        if (field2)
          types.push(field2.type);
        return types;
      },
      [type]
    );
    let field = null;
    possibleTypes.forEach((type2) => {
      const found = type2.fields && type2.fields[f];
      if (found)
        field = found;
    });
    if (!field)
      throw new Error(
        `type \`${type.name}\` does not have a field \`${f}\``
      );
    current = field;
  });
  return current;
};

// .basehub/runtime/_create-client.ts
var createClient = ({
  queryRoot,
  mutationRoot,
  subscriptionRoot,
  ...options
}) => {
  const fetcher = createFetcher(options);
  const client = {};
  if (queryRoot) {
    client.query = (request) => {
      if (!queryRoot)
        throw new Error("queryRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("query", queryRoot, request)
      );
      return resultPromise;
    };
  }
  if (mutationRoot) {
    client.mutation = (request) => {
      if (!mutationRoot)
        throw new Error("mutationRoot argument is missing");
      const resultPromise = fetcher(
        generateGraphqlOperation("mutation", mutationRoot, request)
      );
      return resultPromise;
    };
  }
  return client;
};

// .basehub/runtime/_link-type-map.ts
var linkTypeMap = (typeMap2) => {
  const indexToName = Object.assign(
    {},
    ...Object.keys(typeMap2.types).map((k, i) => ({ [i]: k }))
  );
  let intermediaryTypeMap = Object.assign(
    {},
    ...Object.keys(typeMap2.types || {}).map(
      (k) => {
        const type = typeMap2.types[k];
        const fields = type || {};
        return {
          [k]: {
            name: k,
            // type scalar properties
            scalar: Object.keys(fields).filter((f) => {
              const [type2] = fields[f] || [];
              const isScalar = type2 && typeMap2.scalars.includes(type2);
              if (!isScalar) {
                return false;
              }
              const args = fields[f]?.[1];
              const argTypes = Object.values(args || {}).map((x) => x?.[1]).filter(Boolean);
              const hasRequiredArgs = argTypes.some(
                (str) => str && str.endsWith("!")
              );
              if (hasRequiredArgs) {
                return false;
              }
              return true;
            }),
            // fields with corresponding `type` and `args`
            fields: Object.assign(
              {},
              ...Object.keys(fields).map(
                (f) => {
                  const [typeIndex, args] = fields[f] || [];
                  if (typeIndex == null) {
                    return {};
                  }
                  return {
                    [f]: {
                      // replace index with type name
                      type: indexToName[typeIndex],
                      args: Object.assign(
                        {},
                        ...Object.keys(args || {}).map(
                          (k2) => {
                            if (!args || !args[k2]) {
                              return;
                            }
                            const [
                              argTypeName,
                              argTypeString
                            ] = args[k2];
                            return {
                              [k2]: [
                                indexToName[argTypeName],
                                argTypeString || indexToName[argTypeName]
                              ]
                            };
                          }
                        )
                      )
                    }
                  };
                }
              )
            )
          }
        };
      }
    )
  );
  const res = resolveConcreteTypes(intermediaryTypeMap);
  return res;
};
var resolveConcreteTypes = (linkedTypeMap) => {
  Object.keys(linkedTypeMap).forEach((typeNameFromKey) => {
    const type = linkedTypeMap[typeNameFromKey];
    if (!type.fields) {
      return;
    }
    const fields = type.fields;
    Object.keys(fields).forEach((f) => {
      const field = fields[f];
      if (field.args) {
        const args = field.args;
        Object.keys(args).forEach((key) => {
          const arg = args[key];
          if (arg) {
            const [typeName2] = arg;
            if (typeof typeName2 === "string") {
              if (!linkedTypeMap[typeName2]) {
                linkedTypeMap[typeName2] = { name: typeName2 };
              }
              arg[0] = linkedTypeMap[typeName2];
            }
          }
        });
      }
      const typeName = field.type;
      if (typeof typeName === "string") {
        if (!linkedTypeMap[typeName]) {
          linkedTypeMap[typeName] = { name: typeName };
        }
        field.type = linkedTypeMap[typeName];
      }
    });
  });
  return linkedTypeMap;
};

// .basehub/types.ts
var types_default = {
  "scalars": [
    0,
    13,
    15,
    16,
    17,
    18,
    19,
    27
  ],
  "types": {
    "AnalyticsKeyScope": {},
    "BaseRichTextJson": {
      "blocks": [
        27
      ],
      "content": [
        19
      ],
      "toc": [
        19
      ],
      "__typename": [
        27
      ]
    },
    "BlockAudio": {
      "fileName": [
        27
      ],
      "fileSize": [
        18
      ],
      "lastModified": [
        16
      ],
      "mimeType": [
        27
      ],
      "url": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockCodeSnippet": {
      "allowedLanguages": [
        27
      ],
      "code": [
        27
      ],
      "html": [
        27,
        {
          "theme": [
            27
          ]
        }
      ],
      "language": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockColor": {
      "b": [
        18
      ],
      "g": [
        18
      ],
      "hex": [
        27
      ],
      "hsl": [
        27
      ],
      "r": [
        18
      ],
      "rgb": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockDocument": {
      "_analyticsKey": [
        27,
        {
          "scope": [
            0
          ]
        }
      ],
      "_id": [
        27
      ],
      "_idPath": [
        27
      ],
      "_slug": [
        27
      ],
      "_slugPath": [
        27
      ],
      "_sys": [
        6
      ],
      "_title": [
        27
      ],
      "on_Sarasa": [
        26
      ],
      "__typename": [
        27
      ]
    },
    "BlockDocumentSys": {
      "apiNamePath": [
        27
      ],
      "createdAt": [
        27
      ],
      "hash": [
        27
      ],
      "id": [
        17
      ],
      "idPath": [
        27
      ],
      "lastModifiedAt": [
        27
      ],
      "slug": [
        27
      ],
      "slugPath": [
        27
      ],
      "title": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockFile": {
      "fileName": [
        27
      ],
      "fileSize": [
        18
      ],
      "lastModified": [
        16
      ],
      "mimeType": [
        27
      ],
      "url": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockImage": {
      "alt": [
        27
      ],
      "aspectRatio": [
        27
      ],
      "fileName": [
        27
      ],
      "fileSize": [
        18
      ],
      "height": [
        18
      ],
      "lastModified": [
        16
      ],
      "mimeType": [
        27
      ],
      "placeholderURL": [
        27
      ],
      "rawUrl": [
        27
      ],
      "thumbhash": [
        27
      ],
      "url": [
        27,
        {
          "anim": [
            27
          ],
          "background": [
            27
          ],
          "blur": [
            18
          ],
          "border": [
            27
          ],
          "brightness": [
            18
          ],
          "compression": [
            27
          ],
          "contrast": [
            18
          ],
          "dpr": [
            18
          ],
          "fit": [
            27
          ],
          "format": [
            27
          ],
          "gamma": [
            27
          ],
          "gravity": [
            27
          ],
          "height": [
            18
          ],
          "metadata": [
            27
          ],
          "quality": [
            18
          ],
          "rotate": [
            27
          ],
          "sharpen": [
            27
          ],
          "trim": [
            27
          ],
          "width": [
            18
          ]
        }
      ],
      "width": [
        18
      ],
      "__typename": [
        27
      ]
    },
    "BlockList": {
      "_analyticsKey": [
        27,
        {
          "scope": [
            0
          ]
        }
      ],
      "_id": [
        27
      ],
      "_idPath": [
        27
      ],
      "_meta": [
        21
      ],
      "_searchKey": [
        27
      ],
      "_slug": [
        27
      ],
      "_slugPath": [
        27
      ],
      "_sys": [
        6
      ],
      "_title": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockOgImage": {
      "url": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "BlockRichText": {
      "html": [
        27,
        {
          "slugs": [
            13
          ],
          "toc": [
            13
          ]
        }
      ],
      "json": [
        25
      ],
      "markdown": [
        27
      ],
      "plainText": [
        27
      ],
      "readingTime": [
        18,
        {
          "wpm": [
            18
          ]
        }
      ],
      "__typename": [
        27
      ]
    },
    "BlockVideo": {
      "aspectRatio": [
        27
      ],
      "fileName": [
        27
      ],
      "fileSize": [
        18
      ],
      "height": [
        18
      ],
      "lastModified": [
        16
      ],
      "mimeType": [
        27
      ],
      "url": [
        27
      ],
      "width": [
        18
      ],
      "__typename": [
        27
      ]
    },
    "Boolean": {},
    "DateFilter": {
      "eq": [
        15
      ],
      "isAfter": [
        15
      ],
      "isBefore": [
        15
      ],
      "neq": [
        15
      ],
      "onOrAfter": [
        15
      ],
      "onOrBefore": [
        15
      ],
      "__typename": [
        27
      ]
    },
    "DateTime": {},
    "Float": {},
    "ID": {},
    "Int": {},
    "JSON": {},
    "ListFilter": {
      "isEmpty": [
        13
      ],
      "length": [
        18
      ],
      "__typename": [
        27
      ]
    },
    "ListMeta": {
      "totalCount": [
        18
      ],
      "__typename": [
        27
      ]
    },
    "NumberFilter": {
      "eq": [
        16
      ],
      "gt": [
        16
      ],
      "gte": [
        16
      ],
      "lt": [
        16
      ],
      "lte": [
        16
      ],
      "neq": [
        16
      ],
      "__typename": [
        27
      ]
    },
    "Query": {
      "_sys": [
        24
      ],
      "sarasa": [
        26
      ],
      "__typename": [
        27
      ]
    },
    "RepoSys": {
      "hash": [
        27
      ],
      "id": [
        17
      ],
      "slug": [
        27
      ],
      "title": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "RichTextJson": {
      "content": [
        19
      ],
      "toc": [
        19
      ],
      "on_BaseRichTextJson": [
        1
      ],
      "__typename": [
        27
      ]
    },
    "Sarasa": {
      "_analyticsKey": [
        27,
        {
          "scope": [
            0
          ]
        }
      ],
      "_id": [
        27
      ],
      "_idPath": [
        27
      ],
      "_slug": [
        27
      ],
      "_slugPath": [
        27
      ],
      "_sys": [
        6
      ],
      "_title": [
        27
      ],
      "title": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "String": {},
    "StringFilter": {
      "contains": [
        27
      ],
      "endsWith": [
        27
      ],
      "eq": [
        27
      ],
      "matches": [
        29
      ],
      "notEq": [
        27
      ],
      "startsWith": [
        27
      ],
      "__typename": [
        27
      ]
    },
    "StringMatchesFilter": {
      "caseSensitive": [
        13
      ],
      "pattern": [
        27
      ],
      "__typename": [
        27
      ]
    }
  }
};

// .basehub/schema.ts
function fragmentOn(name, fields) {
  return { __fragmentOn: name, ...fields };
}
function fragmentOnRecursiveCollection(name, fields, options) {
  let current = {
    ...fields
  };
  if (options.levels > 0) {
    current[options.recursiveKey] = {
      ...options.getLevelArgs ? { __args: options.getLevelArgs(options.levels) } : {},
      items: fragmentOnRecursiveCollection(name, fields, {
        ...options,
        levels: options.levels - 1
      })
    };
  }
  return current;
}

// .basehub/index.ts
var typeMap = linkTypeMap(types_default);
var createClient2 = function(options) {
  const { url, headers } = getStuffFromEnv(options);
  return createClient({
    url: url.toString(),
    ...options,
    headers: { ...options?.headers, ...headers },
    queryRoot: typeMap.Query,
    mutationRoot: typeMap.Mutation,
    subscriptionRoot: typeMap.Subscription
  });
};
var everything = {
  __scalar: true
};
var generateQueryOp = function(fields) {
  return generateGraphqlOperation("query", typeMap.Query, fields);
};
var getStuffFromEnv = (options) => {
  const defaultEnvVarPrefix = "BASEHUB";
  options = options || {};
  if (options.token === void 0) {
    options.token = null;
  }
  if (options.prefix === void 0) {
    options.prefix = null;
  }
  if (!options.draft && true) {
    options.draft = true;
  }
  const buildEnvVarName = (name) => {
    let prefix = defaultEnvVarPrefix;
    if (options.prefix) {
      if (options.prefix.endsWith("_")) {
        options.prefix = options.prefix.slice(0, -1);
      }
      if (options.prefix.endsWith(name)) {
        options.prefix = options.prefix.slice(0, -name.length);
      }
      if (options.prefix.endsWith(defaultEnvVarPrefix)) {
        prefix = options.prefix;
      } else {
        prefix = `${options.prefix}_${defaultEnvVarPrefix}`;
      }
    }
    return `${prefix}_${name}`;
  };
  const getEnvVar = (name) => process.env[buildEnvVarName(name)];
  const parsedDebugForcedURL = getEnvVar("DEBUG_FORCED_URL");
  const parsedBackwardsCompatURL = getEnvVar("URL");
  const backwardsCompatURL = parsedBackwardsCompatURL ? new URL(parsedBackwardsCompatURL) : void 0;
  const basehubUrl = new URL(
    parsedDebugForcedURL ? parsedDebugForcedURL : `https://api.basehub.com/graphql`
  );
  const parsedBasehubTokenEnv = getEnvVar("TOKEN");
  const parsedBasehubRefEnv = getEnvVar("REF");
  const parsedBasehubDraftEnv = getEnvVar("DRAFT");
  const parsedBasehubApiVersionEnv = getEnvVar("API_VERSION");
  const resolveTokenParam = (token2) => {
    if (!token2)
      return null;
    const isRaw = token2.startsWith("bshb_");
    if (isRaw)
      return token2;
    return process.env[token2] ?? "";
  };
  const resolvedToken = resolveTokenParam(options?.token ?? null);
  const token = resolvedToken ?? basehubUrl.searchParams.get("token") ?? parsedBasehubTokenEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("token") : void 0) ?? null;
  if (!token) {
    throw new Error(
      `\u{1F534} Token not found. Make sure to include the ${buildEnvVarName("TOKEN")} env var.`
    );
  }
  const ref = basehubUrl.searchParams.get("ref") ?? parsedBasehubRefEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("ref") : void 0) ?? null;
  let draft = basehubUrl.searchParams.get("draft") ?? parsedBasehubDraftEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("draft") : void 0) ?? false;
  if (options?.draft !== void 0) {
    draft = options.draft;
  }
  let apiVersion = basehubUrl.searchParams.get("api-version") ?? parsedBasehubApiVersionEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("api-version") : void 0) ?? "2";
  if (options?.apiVersion !== void 0) {
    apiVersion = options.apiVersion;
  }
  if (basehubUrl.pathname.split("/")[1] !== "graphql") {
    throw new Error(`\u{1F534} Invalid URL. The URL needs to point your repo's GraphQL endpoint, so the pathname should end with /graphql.`);
  }
  basehubUrl.searchParams.delete("token");
  basehubUrl.searchParams.delete("ref");
  basehubUrl.searchParams.delete("draft");
  basehubUrl.searchParams.delete("api-version");
  return {
    isForcedDraft: true,
    draft,
    url: basehubUrl,
    headers: {
      "x-basehub-token": token,
      ...ref ? { "x-basehub-ref": ref } : {},
      ...draft ? { "x-basehub-draft": "true" } : {},
      ...apiVersion ? { "x-basehub-api-version": apiVersion } : {}
    }
  };
};
var basehub = (options) => {
  const { url, headers } = getStuffFromEnv(options);
  return {
    ...createClient2({ ...options, next: { revalidate: 0 } }),
    raw: createFetcher({ ...options, url, headers })
  };
};
export {
  GenqlError,
  basehub,
  everything,
  fragmentOn,
  fragmentOnRecursiveCollection,
  generateQueryOp,
  getStuffFromEnv
};
